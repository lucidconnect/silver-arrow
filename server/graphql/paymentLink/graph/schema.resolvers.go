package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"

	"github.com/google/uuid"
	"github.com/lucidconnect/silver-arrow/core/merchant"
	"github.com/lucidconnect/silver-arrow/core/wallet"
	"github.com/lucidconnect/silver-arrow/gqlerror"
	"github.com/lucidconnect/silver-arrow/server/graphql/paymentLink/graph/generated"
	"github.com/lucidconnect/silver-arrow/server/graphql/paymentLink/graph/model"
)

// ResolvePaymentLinkBySession is the resolver for the resolvePaymentLinkBySession field.
func (r *queryResolver) ResolvePaymentLinkBySession(ctx context.Context, id string) (*model.PaymentLinkDetails, error) {
	merchantService := merchant.NewMerchantService(r.Database, uuid.Nil)

	sid, err := uuid.Parse(id)
	if err != nil {
		return nil, gqlerror.ErrToGraphQLError(gqlerror.InternalError, err.Error(), ctx)
	}
	checkoutSession, err := r.Database.FetchCheckoutSession(sid)
	if err != nil {
		return nil, gqlerror.ErrToGraphQLError(gqlerror.InternalError, err.Error(), ctx)
	}

	paymentLinkId := checkoutSession.PaymentLinkID.String()
	paymentLinkQuery := merchant.PaymentLinkQueryParams{
		PaymentLinkId: &paymentLinkId,
	}
	pd, err := merchantService.FetchPaymentLink(paymentLinkQuery)
	if err != nil {
		return nil, gqlerror.ErrToGraphQLError(gqlerror.InternalError, err.Error(), ctx)
	}
	paymentLinkDetails := &model.PaymentLinkDetails{
		ID:           pd.ID,
		Mode:         pd.Mode,
		ProductID:    pd.ProductID,
		MerchantID:   pd.MerchantID,
		Amount:       pd.Amount,
		Token:        pd.Token,
		Chain:        pd.Chain,
		ProductName:  pd.ProductName,
		MerchantName: pd.MerchantName,
		Interval:     pd.Interval,
		CallbackURL:  checkoutSession.CallbackURL,
	}
	return paymentLinkDetails, nil
}

// ResolvePaymentLink is the resolver for the resolvePaymentLink field.
func (r *queryResolver) ResolvePaymentLink(ctx context.Context, id string) (*model.PaymentLinkDetails, error) {
	merchantService := merchant.NewMerchantService(r.Database, uuid.Nil)

	paymentLinkQuery := merchant.PaymentLinkQueryParams{
		PaymentLinkId: &id,
	}
	pd, err := merchantService.FetchPaymentLink(paymentLinkQuery)
	if err != nil {
		return nil, gqlerror.ErrToGraphQLError(gqlerror.InternalError, err.Error(), ctx)
	}
	paymentLinkDetails := &model.PaymentLinkDetails{
		ID:           pd.ID,
		Mode:         pd.Mode,
		ProductID:    pd.ProductID,
		MerchantID:   pd.MerchantID,
		Amount:       pd.Amount,
		Token:        pd.Token,
		Chain:        pd.Chain,
		ProductName:  pd.ProductName,
		MerchantName: pd.MerchantName,
		Interval:     pd.Interval,
		IntervalUnit: pd.IntervalUnit.String(),
		CallbackURL:  pd.CallbackURL,
	}
	return paymentLinkDetails, nil
}

// GetBillingHistory is the resolver for the getBillingHistory field.
func (r *queryResolver) GetBillingHistory(ctx context.Context, walletAddress string, productID string) ([]*model.BillingHistory, error) {
	var billingHistory []*model.BillingHistory

	walletService := wallet.NewWalletService(r.Database, 0)
	bh, err := walletService.FetchUserBillingHistory(walletAddress, productID)
	if err != nil {
		return nil, gqlerror.ErrToGraphQLError(gqlerror.InternalError, err.Error(), ctx)
	}

	for _, b := range bh {

		billing := &model.BillingHistory{
			Date:        b.Date,
			Amount:      b.Amount,
			ExplorerURL: b.ExplorerURL,
		}

		billingHistory = append(billingHistory, billing)

	}
	return billingHistory, nil
}

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
